So the answer I am looking for is C, the O(n) or covalently we would say that the running time of this algorithm is linear
in the input length n. Why is that true?
Well, let's think about how many operations this piece of code is going to
execute. Actually, the lines of code executed is
going to depend on the input. It depends on whether or not the target t
is contained in the array a, and if so, where in the array a it lies.
But, in the worse case, this code will do an unsuccessful search.
>> T will not be in the array and the code will scan through the entire array A
and return false. The number of operations then is a
constant. There's some initial setup perhaps and
maybe it's an operation to return this final boolean value, but outside of that
constant which will get suppressed in the big annotation, it does a constant number
of operations per entry in the array. And you could argue about what the
constant is, if it's 2, 3, 4 operations per entry in the array, but the point it
whatever that constant is, 2, 3, or 4, it gets conveniently suppressed by the Big O
notation. So as a result, total number of
operations will be linear in n, and so the Big O notation will just be O of N.
So that was the first example, and the last three examples, I want to look at
different ways that we could have two loops.
And in this example, I want to think about one loop followed by another.
So two loops in sequence. I want to study almost the same problem
as the previous one. Where now we're just given two arrays,
capital a and capital b, we'll say both of the same length n, and we want to know
whether the target t is in either one of them.
Again, we'll look at the straightforward algorithm, where we just search through
A, and if we fail to find t in A, we search through B.
If we don't find t in B either, then we have to return false.
So the question then is exactly the same as last time.
Given this new longer piece of code, what, in big O notation, is its running
time?